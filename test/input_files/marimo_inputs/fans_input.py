import marimo

__generated_with = "0.7.20"
app = marimo.App(width="medium", layout_file="fans_input.grid.json")


@app.cell
def __():
    import marimo as mo

    return (mo,)


@app.cell
def __():
    import json

    return (json,)


@app.cell
def __(get_fans_input, set_fans_input):
    # General methods to change the state of fans_input via methods, for giving to ui elements
    def change_input(key):
        def f(val):
            temp = get_fans_input()
            temp[key] = val
            set_fans_input(temp)

        return f

    def get_input_value(key):
        try:
            return get_fans_input()[key]
        except:
            return None

    return change_input, get_input_value


@app.cell
def __(change_input, mo):
    # Function to create an array input of numbers
    def create_array_input(
        name, length, values, start=-1e5, stop=1e5, on_change=None, **kwargs
    ):
        t = []
        vals = {}
        for i in range(length):
            try:
                vals[i] = values[i]
            except:
                vals[i] = 0
            # print(f"Creating array input {name} with length {length} and {values}, currently {i} and value {vals[i]}")
            t.append(mo.ui.number(start, stop, value=vals[i], **kwargs))
        if on_change:
            # take custom function (for subfields)
            out = mo.ui.array(t, label=name, on_change=on_change)
            # print(f"{on_change=}")
            # on_change(vals) # DANGER! breaks the notebook! needs to restart session! manual on_change trigger
            return out
        else:
            # take general function (for general json fields)
            return mo.ui.array(t, label=name, on_change=change_input(name))

    return (create_array_input,)


@app.cell
def __(create_array_input, mo, ui_number_of_phases):
    # Function to create a nested array input, such as material_properties: creates a ui array holding ui_arrays.
    def create_nested_array_input(
        name, subnames, values, on_change, start=-1e5, stop=1e5, **kwargs
    ):
        t = []
        for i, subname in enumerate(subnames):
            # print(f"Creating array for {name}, with {subname}, current value:{values[subname]}")
            t1 = create_array_input(
                subname,
                ui_number_of_phases.value,
                values[subname],
                on_change=on_change(subname),
            )
            t.append(t1)
        out = mo.ui.array(t, label=name)
        return out

    return (create_nested_array_input,)


@app.cell
def __():
    # Standard input: could also be done by reading in a file, which then gets changed, or clean this out to sth more general...
    input_standard = {
        "comment": "This field is ignored and can be used to describe the format. 'problem_type' can be 'thermal' or 'mechanical'. 'method' can be 'fp' or 'cg'. 'matmodel' can be 'ThermalLinear', 'MechLinear' or 'HyperElastic'. g0 is the macroscale loading vectors - each row is a new loading condition",
        "ms_filename": "microstructures/sphere32.h5",
        "ms_datasetname": "/sphere/32x32x32/ms",
        "ms_L": [1.0, 1.0, 1.0],
        "problem_type": "mechanical",
        "matmodel": "HyperElastic",
        "material_properties": {
            "bulk_modulus": [62.5000, 222.222],
            "shear_modulus": [28.8462, 166.6667],
            "critical_stress": [0.1, 10000],
            "hardening_parameter": [0.0, 0.0],
        },
        "method": "cg",
        "TOL": 1e-10,
        "n_it": 500,
        "g0": [0.010, -0.010, 0, 0.0, 0, 0],
        "results": [],
    }
    return (input_standard,)


@app.cell
def __(input_standard):
    # Generate starter dictionary by updating the reference with a comment -> not really needed, but already there...
    input_dict = {"comment": "This is auto-generated by a marimo-notebook!"}
    input_dict.update(input_standard)
    return (input_dict,)


@app.cell
def __(input_dict, mo):
    # Create the state of the fans input
    get_fans_input, set_fans_input = mo.state(input_dict)
    return get_fans_input, set_fans_input


@app.cell
def __(get_fans_input, json, mo):
    # Create download button
    download_txt = mo.download(
        data=json.dumps(get_fans_input(), indent=5),
        filename="test.json",
        # mimetype="text/plain",
    )
    return (download_txt,)


@app.cell
def __(mo):
    # Needs to be in separate cell to other ui elements -> they get refreshed with state
    ui_number_of_phases = mo.ui.number(
        start=2, stop=6, value=2, label="Number of Phases"
    )
    return (ui_number_of_phases,)


@app.cell
def __(change_input, create_array_input, get_input_value, mo):
    # General ui elements
    ui_ms_filename = mo.ui.text(
        value=get_input_value("ms_filename"),
        label="ms_filename",
        on_change=change_input("ms_filename"),
        max_length=100,
    )
    ui_problem_dropdown = mo.ui.dropdown(
        options=["mechanical", "thermal"],
        value=get_input_value("problem_type"),
        label="Problem type:",
        on_change=change_input("problem_type"),
    )
    ui_ms_L = create_array_input("ms_L", 3, values=get_input_value("ms_L"))
    return ui_ms_L, ui_ms_filename, ui_problem_dropdown


@app.cell
def __(change_input, get_input_value, mo, ui_problem_dropdown):
    # Problem changer -> changes the dropdown for selecting the material model
    match ui_problem_dropdown.value:
        case "mechanical":
            ui_matmodel_dropdown = mo.ui.dropdown(
                options=["MechLinear", "HyperElastic"],
                value=get_input_value("matmodel"),
                label="Material Model:",
                on_change=change_input("matmodel"),
            )
        case "thermal":
            ui_matmodel_dropdown = mo.md("Not defined yet!")
    return (ui_matmodel_dropdown,)


@app.cell
def __(
    create_nested_array_input,
    get_fans_input,
    get_input_value,
    mo,
    set_fans_input,
):
    # cell which creates the ui to select material parameters
    # currently no distingishing between problem types -> need of unique names for material laws!
    # New function to just alter material_properties: basically goes down one level in the dict/json
    # TODO: could be wrapped in another function, varyiing the indentation key
    def change_material(key):
        def f(val):
            temp = get_fans_input()
            temp["material_properties"][key] = val
            set_fans_input(temp)

        return f

    ui_matmodel_parameters = mo.md("Material parameters not prepared!")
    match get_fans_input()["matmodel"]:
        case "MechLinear":
            subnames = [
                "bulk_modulus",
                "shear_modulus",
                "critical_stress",
                "hardening_parameter",
            ]
            ui_matmodel_parameters = create_nested_array_input(
                "material_properties",
                subnames,
                values=get_input_value("material_properties"),
                on_change=change_material,
            )
        case "HyperElastic":
            pass
    return change_material, subnames, ui_matmodel_parameters


@app.cell
def __(
    mo,
    ui_matmodel_dropdown,
    ui_matmodel_parameters,
    ui_ms_L,
    ui_ms_filename,
    ui_number_of_phases,
    ui_problem_dropdown,
):
    # General form
    # could also be done as "form", so a button press would be needed to change all the values
    mo.vstack(
        [
            ui_ms_filename,
            ui_number_of_phases,
            ui_ms_L,
            ui_problem_dropdown,
            ui_matmodel_dropdown,
            ui_matmodel_parameters,
        ]
    )
    return


@app.cell
def __(get_fans_input, json):
    json.dumps(get_fans_input(), indent=5)
    return


@app.cell
def __(download_txt):
    download_txt
    return


@app.cell
def __():
    return


if __name__ == "__main__":
    app.run()
